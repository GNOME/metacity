#!/usr/bin/python
#
# metacity-test.py -- testing for Metacity
# 
# Copyright (C) 2008 Thomas Thurman
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#

import sys
import inspect
import getopt

class Test(object):
    """Grandfather of all tests.  (Yes, I know about the 'unittest'
    module; I think what we're doing here isn't terribly similar.)"""
    # If when we get this working I'm shown to be wrong, well,
    # that's fine too.
    pass

tests_by_name = {}
tests_by_bug_number = {}

#################
#
#  These belong in a file, one of several in a subdirectory
#  which gets scanned, so we can easily do plugins, and so
#  we get precompilation.
#
#  There will be class decorators in Python 2.6, but until
#  we get them, we will make do with adding the classes to
#  dictionaries directly.

class BuildTest(Test):
    "Convenience class to build others around"

    # FIXME: nts: what differs, *params, **params
    def run_build(**params):
        pass

class test_ansi(BuildTest):
    def run(self):
        return self.run_build(c='ansi')

class test_gconfoff(BuildTest):
    def run(self):
        return self.run_build(configure='--disable-gconf')

class test_compositoroff(BuildTest):
    def run(self):
        return self.run_build(configure='--disable-compositor')

class test_teston(BuildTest):
    def run(self):
        return self.run_build(configure='--enable-testing')

class test_distcheck(BuildTest):
    def run(self):
        return self.run_build(action='distcheck')

# Populate tests_by_name by introspection
for (name, klass) in inspect.getmembers(sys.modules['__main__']):
    if not name.startswith('test_'): continue

    tests_by_name[name[5:]] = klass

#################
#
#  And back in the ordinary world...

def show_help():
    print '  --- metacity-test ---  a test system for metacity.'
    print 'There are three kinds of test: unit, regression, or build.'
    print 'Only build tests are currently implemented.'
    print
    print 'Syntax:'
    print '  metacity-test <switches> <test names>'
    print 'where <switches> can be:'
    print '  -h    Show this help and exit'
    print '  -l    List all known tests and exit'
    print '  -r=n  Use revision n, or directory n as pristine'
    print '          (defaults to /usr/local/src/metacity if you have it)'
    print

def show_tests():
    print 'Build tests:'
    for name in tests_by_name.keys():
        test = tests_by_name[name]
        if test.__doc__:
            print '     %s - %s' % (name, test.__doc__)
        else:
            print '     %s' % (name)

    print
    print 'Unit tests:'
    print '  -- Not yet implemented.'
    print
    print 'Regression tests:'
    print '  -- Not yet implemented.'

def main():
    try:
        (opts, testlist) = getopt.gnu_getopt(
            sys.argv[1:],
            'lhr=',
            )
    except getopt.GetoptError, e:
        print 'Error:', e
        print 'Use -h for help, or -l to list all tests.'
        sys.exit(1)

    if (len(opts)==0 and len(testlist)==0) or (('-h', '') in opts):
        show_help()
    elif ('-l', '') in opts:
        show_tests()
    elif not testlist:
        print "Warning: You didn't specify any tests to run."
    else:
        # Later we need to add
        #  - .foo = all with the tag "foo"
        #  - .build, etc., which are implicit tags
        #  - for regression tests, selection by bug number
        #  - very simple dependencies (you need the output of a particular build
        #    test before you can run a given unit test on it!)

        tests_to_run = {}
        tests_that_dont_exist = []

        switch_polarity = 0

        for test in testlist:
            if test in ('all', 'allbut'):
                switch_polarity = 1
            elif tests_by_name.has_key(test):
                tests_to_run[test] = tests_by_name[test]
            else:
                tests_that_dont_exist.append(test)

        if tests_that_dont_exist:
            print 'You asked for these tests which don\'t exist:', ' '.join(tests_that_dont_exist)
            print 'Stopping now until you decide what you really want.'
            print 'Try the -l option, maybe.'
            sys.exit(1)

        if switch_polarity:
            temp = {}
            for test in tests_by_name.keys():
                if not tests_to_run.has_key(test):
                    temp[test] = tests_by_name[test]
            tests_to_run = temp

        print tests_to_run

if __name__=='__main__':
    main()
