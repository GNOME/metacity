#!/usr/bin/python
#
# metacity-test.py -- testing for Metacity
# 
# Copyright (C) 2008 Thomas Thurman
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#

import sys
import inspect
import getopt
import os
import tempfile

class Test(object):
    """Grandfather of all tests.  (Yes, I know about the 'unittest'
    module; I think what we're doing here isn't terribly similar.)"""
    # If when we get this working I'm shown to be wrong, well,
    # that's fine too.
    pass

tests_by_name = {}
tests_by_bug_number = {}

pristine_copy = '/usr/local/src/metacity'

def run(command):
    "Executes a command.  It's here so we can toggle dry runs."
    print 'Run %s' % command
    result = os.system(command)
    print 'Return result of %s was %d' % (command, result)
    return result == 0

#################
#
#  These belong in a file, one of several in a subdirectory
#  which gets scanned, so we can easily do plugins, and so
#  we get precompilation.
#
#  There will be class decorators in Python 2.6, but until
#  we get them, we will make do with adding the classes to
#  dictionaries directly.

class BuildTest(Test):
    "Convenience class to build others around"

    def run_build(self, **params):
        """Generalised routine to attempt to build Metacity.

        Parameters are:
        action = (string)  -- run "make (string)" rather than "make"
        autogen = (string) -- opts for autogen (or its kids)
        c = (string) -- C flags
        """
        print 'Here we are.', params
        print 'We would:'
        working_directory = pristine_copy
        if False:
            # This is an idea I had about copying everything into /tmp
            # so we could work with -r being a r/o directory.
            # It slows everything down to turn it on by default, though.
            # XXX allow people to turn it on.
            temp_directory = tempfile.mkdtemp(prefix='metatest_')
            if run('cp -LpR %s %s' % (pristine_copy, temp_directory))!=0:
                print 'There were errors during copying (your repository is probably'
                print 'a little untidy).  Please go and tidy up and then come back.'
                return False
            working_directory = temp_directory

        makefile = os.path.join(working_directory, 'Makefile')

        os.chdir (working_directory)

        if os.path.lexists (makefile):
            if not run ("make distclean"):
                print 'Could not clean up; this is bad'
                return False
        else:
            print 'No need to distclean'

        autogen_opts = ''
        if params.has_key ('autogen'):
            autogen_opts = params['autogen']

        if not run('./autogen.sh %s' % autogen_opts):
            print 'Autogen failed; can\'t really go on from here.'
            return False

        return True

class test_ansi(BuildTest):
    def run(self, **params):
        return self.run_build(c='ansi')

class test_gconfoff(BuildTest):
    def run(self, **params):
        return self.run_build(autogen='--disable-gconf')

class test_compositoroff(BuildTest):
    def run(self, **params):
        return self.run_build(autogen='--disable-compositor')

class test_teston(BuildTest):
    def run(self, **params):
        return self.run_build(autogen='--enable-testing')

class test_distcheck(BuildTest):
    def run(self, **params):
        return self.run_build(action='distcheck')

# Populate tests_by_name by introspection
for (name, klass) in inspect.getmembers(sys.modules['__main__']):
    if not name.startswith('test_'): continue

    tests_by_name[name[5:]] = klass

#################
#
#  And back in the ordinary world...

def show_help():
    print '  --- metacity-test ---  a test system for metacity.'
    print 'There are three kinds of test: unit, regression, or build.'
    print 'Only build tests are currently implemented.'
    print
    print 'Syntax:'
    print '  metacity-test <switches> <test names>'
    print 'where <switches> can be:'
    print '  -h    Show this help and exit'
    print '  -l    List all known tests and exit'
    print '  -r=n  Use revision n, or directory n as pristine'
    print '          (defaults to %s if you have it)' % pristine_copy
    print

def show_tests():
    print 'Build tests:'
    for name in tests_by_name.keys():
        test = tests_by_name[name]
        if test.__doc__:
            print '     %s - %s' % (name, test.__doc__)
        else:
            print '     %s' % (name)

    print
    print 'Unit tests:'
    print '  -- Not yet implemented.'
    print
    print 'Regression tests:'
    print '  -- Not yet implemented.'

def main():
    try:
        (opts, testlist) = getopt.gnu_getopt(
            sys.argv[1:],
            'lhr=',
            )
    except getopt.GetoptError, e:
        print 'Error:', e
        print 'Use -h for help, or -l to list all tests.'
        sys.exit(1)

    if (len(opts)==0 and len(testlist)==0) or (('-h', '') in opts):
        show_help()
    elif ('-l', '') in opts:
        show_tests()
    elif ('-r', '') in opts:
        print 'Sorry, actual parsing of -r isn\'t written yet; use %s.' % pristine_copy
        sys.exit(1)
    elif not testlist:
        print "Warning: You didn't specify any tests to run."
    else:
        # Later we need to add
        #  - .foo = all with the tag "foo"
        #  - .build, etc., which are implicit tags
        #  - for regression tests, selection by bug number
        #  - very simple dependencies (you need the output of a particular build
        #    test before you can run a given unit test on it!)

        tests_to_run = {}
        tests_that_dont_exist = []

        switch_polarity = 0

        for test in testlist:
            if test in ('all', 'allbut'):
                switch_polarity = 1
            elif tests_by_name.has_key(test):
                tests_to_run[test] = tests_by_name[test]
            else:
                tests_that_dont_exist.append(test)

        if tests_that_dont_exist:
            print 'You asked for these tests which don\'t exist:', ' '.join(tests_that_dont_exist)
            print 'Stopping now until you decide what you really want.'
            print 'Try the -l option, maybe.'
            sys.exit(1)

        if switch_polarity:
            temp = {}
            for test in tests_by_name.keys():
                if not tests_to_run.has_key(test):
                    temp[test] = tests_by_name[test]
            tests_to_run = temp

        # okay, kick it off
        for name in tests_to_run.keys():
            sys.stdout.write('%s... ' % name)
            test = tests_to_run[name]()
            try:
                result = test.run()
                if result:
                    print 'PASS'
                else:
                    print 'FAIL'
            except Exception, e:
                # obviously not good
                print 'FAIL (%s)' % e
            

if __name__=='__main__':
    main()
